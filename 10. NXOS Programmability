NXOS supports two versions of NX-API including NX-API CLI and NX-API REST, NETCONF, on-box Linux and Python scripting capabilities, and several traditional means already familiar to network administrators including the Scheduler feature, Embedded Event Manager, Power on Provisioning

Nexus programmability overview:
     Day-0 Provisioning:
         Zero-Touch device provisioning is commonly associated with compute devices, but network devices have had this capability for years. Power on Auto Provisioning was designed to provide advanced Day-0 provisioning capabilities using an extensible framework. POAP includes the ability to execute Python scripts as part of its workflow. Today, POAP can download and install additional management agents and apply specific configurations that are based on information such as location in a network topology.

         A similar approach is achieved by using Pre-boot Execution Environment. PXE has extended its presence into the network as infrastructure devices are increasingly managed more like servers. NX-OS uses iPXE which utilizes an open source network firmware that is based on gPXE/Etherboot

     Base Features:
         In addition to providing traditional SNMP support, the Nexus platform also provides Python scripting capability on the devices in order to provide programmatic access to the switch CLI to perform various tasks including Power-On Auto Provisioning and Embedded Event Manager actions. The Python interpreter is included in the Cisco NX-OS software

     APIs:
        NX-OS provides a built-in webserver to respond to HTTP calls to the switch in order to improve accessibility, extend capability, and improve manageability of NX-OS. APIs include NETCONF, NX-API CLI, NX-API REST, and XMPP

    Linux on the Switch:
        Nexus switches have always been built upon a Linux foundation making available a native Linux Bash shell, but today NX-OS also provides a Linux guest shell which is a separate Linux environment running on the switch inside a container. Currently utilizing a CentOS distribution, a key benefit for the guest shell is the ability to securely run third-party applications that monitor and control the switch

    Configuration Management:
        NX-OS incorporates a set of tools, features, and capabilities that enable automation. Modern configuration management tools like Puppet, Chef, and Ansible drive programmability

NX-API cli - part1:
    On Cisco Nexus devices, command-line interfaces are run only on the device and used far too often to manage data center networks

    NX-API improves the accessibility of these CLIs by making them available outside of the switch by using HTTP/HTTPS. You can use the NX-API as an extension to the existing Cisco Nexus CLI. The NX-API CLI API is a great for network engineers getting started with the API as it still makes use of commands. It sends commands to the device, wrapped in http/https, but receives structured data back

    You have the ability to send show commands, configuration commands, and Linux commands directly to the switches using NX-API CLI

    The NX-API backend uses the Nginx HTTP server running on nexus switch. The Nginx process, and all its children processes, are under Linux cgroup protection where the CPU and memory usage is capped. If the Nginx resource usage exceeds the cgroup limitations, the Nginx process is restarted and restored

    The NX-API backend uses a lightweight onbox webserver to listen for HTTP requests which are converted to CLI and used to retrieve data or push configurations. The request/response format is encoded with JSON-RPC, JSON, or XML

    NX-API supports XML, JSON, and JSON-RPC, and commands are sent to a single http request within a CLI wrapper. The following examples show the same request and response for “show hostname” for all 3 data encoding formats:
            [
              {
                "jsonrpc": "2.0",
                "method": "cli",
                "params": {
                  "cmd": "show hostname",
                  "version": 1
                },
                "id": 1
              }
            ]

            Matching response

            {
              "jsonrpc": "2.0",
              "result": {
                "body": {
                  "hostname": “n9k2.cisco.com"
                }
              },
              "id": 1
            }

        NX-API supports HTTPS, therefore all communication to the Nexus device can be encrypted. By default, NX-API is integrated into the authentication system on the device. You access the device through the NX-API using user accounts containing a username and password which are contained in the HTTP header

        NX-API is disabled by default and can be enabled by using the feature manager CLI command. NX-API provides a session-based cookie, nxapi_auth, when users first successfully authenticate. The session cookie expires in 600 seconds which is a fixed value that cannot be modified

        With the session cookie, the username and password are included in all subsequent NX-API requests that are sent to the device. If the session cookie is not included with subsequent requests, another session cookie is required and is provided by the authentication process

Enabling nx-api cli:
    The nxapi feature must be enabled via the CLI
    Enable the feature via the command line
    Identify the alternate port being used (if any)
    Identify an HTTPS certificate file to use
    Enable the nxapi sandbox
nxosv# conf t
nxosv(config)# feature nxapi
nxosv(config)# nxapi https port 8443
nxosv(config)# nxapi sandbox

Note: In particular versions of NX-OS, you can also choose which VRF NX-API should be enabled for:
    nxos(config)# nxapi ?
     certificate  Https certificate configuration
     http         Http configuration
     https        Https configuration
     use-vrf      Vrf to be used for nxapi communication

NX-API sandbox:
    The NX-API sandbox is available on the switch itself (accessible via http://switchname) and accessed via a web browser. There are helpful buttons available with commonly used built-in scripts. It is a great way to become familiar with the API because you get to visualize the JSON/XML objects coming back without having to write actual code

    On the right are buttons that are used to select JSON-RPC, JSON, or XML encodings. Commands are entered in the Command Box and executed with the Post button. The Request being sent to the device is displayed in the Request box in the lower left, and the Response output from the device is displayed in the lower right

    When using JSON-RPC, you are always sending a list of JSON objects (dictionaries) even if it’s a list of one (single command). Here is an example of sending show version with the associated Request and Response.The Response is similar in that it’s always a list of dictionaries for JSON-RPC

Note: When using JSON encoding, you only receive a list in the response when you send more than one command as compared to JSON-RPC which always does. JSON sends a dictionary when sending one command but sends a list of dictionaries when sending more than one command

    The NX-API sandbox can convert CLI into Python automatically to help get you started. In the Request box, click the Python button. It uses a built-in Python requests module to convert the commands to a Python script that can be copied into a .py file

Note: keep in mind that api wrapper always use POST for sending cli commands in rest api calls

Note: cli-conf doesn't support structured data, so JSON/XML response will look just like you see it on the cli

NX-API cli - part 2:
    By using the NX-API Sandbox, you can auto-generate Python code to give you a jump a start on writing scripts. There is only a subtle difference with the script in the previous figure that is compared to this one, and it is around using a specific and preferred Python object to simplify authentication. You can see that everything else is nearly identical that is produced by the NX-API sandbox. Of course, it excludes any parsing that you would want to perform

    Take note that even though you are getting information back from the device, it is still an HTTP POST and it is shown using the post method and clicking the POST button within the NX-API sandbox. All requests using NX-API CLI use HTTP POSTs—it is one reason why NX-API CLI is REST-like

  #!/usr/bin/env python

  import requests
  import json
  from requests.auth import HTTPBasicAuth

  if __name__ == "__main__":

      auth = HTTPBasicAuth('cisco', 'cisco')
      headers = {
          'Content-Type': 'application/json'
      }
      payload = {
        "ins_api": {
            "version": "1.0",
            "type": "cli_show",
            "chunk": "0",
            "sid": "1",
            "input": "show version",
            "output_format": "json"
        }
    }
    url = 'http://nxosv/ins'

    response = requests.post(url, data=json.dumps(payload),
                             headers=headers, auth=auth)

  print 'Status Code: ' + str(response.status_code)
  rx_object = json.loads(response.text)
  print json.dumps(rx_object, indent=4)

Note: the url used: http://nxosv/ins

NETCONF:
    NETCONF on the Nexus platform is based off XML Schema Definitions data models and maps to CLI commands. Only supported on nexus 7k&5k, includes rollback on error, stop on error, continue on error, default operations, and candidate config (Cisco-only)

    Nexus supports the interface uses the XML-based Network Configuration Protocol which allows you to manage devices and communicate over the interface with an XML management tool or program. A sample tool that you will use throughout the course is the Python-based NETCONF client called ncclient as well as the on box NETCONF server that allows you to test XML documents

    The Cisco NX-OS implementation of NETCONF requires you to use an SSH session for communication with the device. NETCONF on the Nexus platform is currently implemented leveraging XML Schemas. From within an RPC message, you select one of the NETCONF operations that matches the type of command that you want the device to execute

    NETCONF requirements:
    In order to get started with NETCONF on the Nexus series switches, you must first prepare the client and the server. The client must support NETCONF over SSH as Nexus supports NETCONF as an SSH subsystem. On a Linux system, the default SSH configuration works just fine

    The server, for example, the Nexus switch, must have SSH enabled in order to use the NETCONF XML Management Interface

    No other licensing is required on the Nexus switch in order to use NETCONF

    NETCONF uses default SSH port (22)

    Accessing netconf on a nexus switch:
        The easiest way to directly access the NETCONF subsystem in order to test it is to access the xmlagent service on the Nexus switch. There are two ways to do it:

            You can SSH directly to the xmlagent service by using “-s” flag which tells the server to connect you to the xmlagent subsystem. Note: netconf works, too, as shown in the figure:     ssh cisco@nxosv -s {netconf | xmlagent}

            SSH directly to the switch. Enter the configuration mode and then enter the command xmlagent

        Once you use either of the two above methods, you can then start testing different XML documents that adhere to the XML schemas that Nexus supports

    netconf utilities and tools:
        There are five (5) unique commands and tools to be aware of when using NETCONF on Nexus series switches:
            xmlagent = The SSH service acting as the NETCONF server on the Nexus platform. When you enter the xmlagent command in configuration mode, you can test XML objects and filters directly on the device without being in code. It is similar to sandbox environments such as the NX-API Sandbox that shows you the objects that are required for the request and shows you object in the response. It is very helpful for testing.

            xmlin = an interactive utility to obtain XML Request documents of a particular show command or configuration object. When you enter xmlin configuration mode, you can enter any command as you would in exec or configuration mode. Once the command is entered, the switch displays the associated XML document to perform that action.

            “| xmlin” & “| xmlout” = The pipe options allow you to see the XML Documents for show commands. It includes seeing the XML Request documents (xmlin), but also it shows the XML Response documents (xmlout). Using the pipe options build on what can be in the xmlin tool because it does show you what the response is too.

            ncclient = ncclient is an open source Python NETCONF client. It aims to offer an intuitive API that sensibly maps the XML-encoded nature of NETCONF to Python objects and constructs

Connecting to netconf:
    When you connect to the device, authenticate, and access the Nexus NETCONF SSH subsystem, the device (NETCONF server) responds with its NETCONF capabilities. These capabilities can be based on open, vendor-neutral, or platform/vendor-specific capabilities.

    NETCONF over SSH is initiated by the exchange of a hello message between the client and the XML server. After the initial exchange, the client sends XML requests which the server responds to with XML responses. The client and server terminate requests and responses with the character sequence ]]>]]>.

    Because this character sequence is not valid in XML, the client and the server can interpret when the messages end which keeps communication that is synchronized

    After the NETCONF server (the Nexus switch) sends its capabilities, you (the XML client) must send a hello message with the capabilities that the client supports

    It is simply a copy and paste of a hello object. Everything in bold in this figure was the response by a user/client responding to the server’s hello message

Note: You must end all XML documents with ]]>]]> to support synchronization in NETCONF over SSH

    Once you send your capabilities, you can start sending XML documents to perform the equivalent of show and configuration commands

    e.g:
    Server's hello upon accessing xmlagent over ssh
        cisco@cisco:~$ ssh cisco@nxosv -s netconf
        User Access Verification
        Password:
        <?xml version="1.0" encoding="ISO-8859-1"?>
        <hello xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
          <capabilities>
            <capability>urn:ietf:params:xml:ns:netconf:base:1.0</capability>
            <capability>urn:ietf:params:netconf:base:1.0</capability>
            <capability>urn:ietf:params:netconf:capability:validate:1.0</capability>
            <capability>urn:ietf:params:netconf:capability:writable-running:1.0</capability>
            <capability>urn:ietf:params:netconf:capability:url:1.0?scheme=file</capability>
            <capability>urn:ietf:params:netconf:capability:rollback-on-error:1.0</capability>
            <capability>urn:ietf:params:netconf:capability:candidate:1.0</capability>
            <capability>urn:ietf:params:netconf:capability:confirmed-commit:1.0</capability>
          </capabilities>
          <session-id>12509</session-id>
        </hello>
        ]]>]]>

    client's response to hello:
          cisco@cisco:~$ ssh cisco@nxosv -s netconf
          User Access Verification
          Password:
          <?xml version="1.0" encoding="ISO-8859-1"?>
          <hello xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
          <--omitted – reference previous slide -->
          </hello>
          ]]>]]><?xml version="1.0"?>
          <hello xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
          <capabilities>
          <capability>urn:ietf:params:xml:ns:netconf:base:1.0</capability>
          <capability>urn:ietf:params:netconf:capability:rollback-on-error:1.0</capability>

    sample request:
        <?xml version="1.0" encoding="ISO-8859-1"?>
        <nf:rpc xmlns:nf="urn:ietf:params:xml:ns:netconf:base:1.0" xmlns="http://www.cisco.com/nxos:7.3.1.D1.1.:vdc_mgr" message-id="1">
          <nf:get>
            <nf:filter type="subtree">
              <show>
                <hostname/>
              </show>
            </nf:filter>
          </nf:get>
        </nf:rpc>
        ]]>]]>

       You can make out what it is doing based on the XML tags being used such as <show> and <hostname>. Note that these tags are wrapped under the rpc, get, and filter-type tags as well. It is telling the server that the request is an XML RPC using the NETCONF get operation and the content includes a filter, which is just the show hostname tags

Generating XML documents using the xmlin interactive shell:
    The Nexus platform offers a tool that is called xmlin which is an interactive shell that helps build the appropriate XML Request objects that are needed to communicate with the Nexus server. Enter the xmlin tool by issuing the command xmlin

    When you see the “nxosv(xmlin)#” prompt, you can start entering commands just as you would in exec and configuration mode. Entering the command show hostname generates the exact XML document that was used in the previous figure when interacting with the xmlagent service and tool

    The xmlin interactive tool can also be used to generate XML request documents for configuration objects. You still need to enter configuration mode and enter configuration mode commands just as you would on the NX-OS CLI

        nxosv(xmlin)# config t
        Enter configuration commands, one per line.  End with CNTL/Z.
        nxosv(config)(xmlin)# vlan 20
        % Success
        % Success
        nxosv(config-vlan)(xmlin)# name web_vlan
        % Success
        % Success
        nxosv(config-vlan)(xmlin)# end
        <?xml version="1.0"?>
        <nf:rpc xmlns:nf="urn:ietf:params:xml:ns:netconf:base:1.0" xmlns="http://www.cisco.com/nxos:7.3.1.D1.1.:configure_" xmlns:m="http://www.cisco.com/nxos:7.3.1.D1.1.:_exec" xmlns:m1="http://www.cisco.com/nxos:7.3.1.D1.1.:configure__vlan" message-id="1">
          <nf:edit-config>
            <nf:target>
              <nf:running/>
            </nf:target>
            <nf:config>
              <m:configure>
                <m:terminal>
                  <vlan>
                    <__XML__PARAM__vlan-id-create-delete>
                      <__XML__value>20</__XML__value>
                      <m1:name>
                        <m1:__XML__PARAM__vlan-name>
                          <m1:__XML__value>web_vlan</m1:__XML__value>
                        </m1:__XML__PARAM__vlan-name>
                      </m1:name>
                    </__XML__PARAM__vlan-id-create-delete>
                  </vlan>
                </m:terminal>
              </m:configure>
            </nf:config>
          </nf:edit-config>
        </nf:rpc>
        ]]>]]>

    The Nexus platform supports advanced operations such as being able to roll back the previous configuration when an error is found. It highlights the value of transactions and applying complete objects to Nexus switches such that if there is an error in any command, nothing gets applied to the device. It is in stark contrast to sending CLI commands. For example, if there was an error in command 4, commands 1 through 3 would still be applied, and you would end up with a partial configuration.

    In order to use the error on rollback option, you add the following option in the contents of the edit config operation:
         <nf:error-option>rollback-on-error</nf:error-option>

Generating xml documents for show commands:
    nxosv# show hostname | xmlout
    nxosv# show hostname | xmlin

Using ncclient (python netconf client):
    The ncclient is the common NETCONF client for Python. It only takes a few Python statements to establish a connection to the device, send XML documents, and receive a response

    There are many defaults being used here, but the important parameters to update as you connect to devices are host, port, username, password, and device_params
        device = manager.connect(host=host, port=port, username=user, password=pwd,hostkey_verify=False, device_params={'name': 'nexus'},allow_agent=False, look_for_keys=False)

    You can also see that you need to still need to define a filter the same way that is generated from using the “| xmlin” tool or “xmlin” interactive tool. It is shown in the script as the get_filter variable
        get_filter = """
                <show>
                <hostname>
                </hostname>
                </show>
                """

  In the next statement, the actual XML document is sent to the device. If you wanted to retrieve the full configuration, you would not need a filter, but because you want the hostname, you also include the “subtree” keyword, when using the get operation.
            nc_get_reply = device.get(('subtree', get_filter))

  As you continue to go through the script, notice that there is an attribute that is called “xml” in the NETCONF reply. In this example, the NETCONF reply is saved as “nc_get_reply” which means this object has an attribute that is called xml. This attribute stores the XML string equivalent of the actual XML object. In this figure, the string was split into two individual text boxes to improve readability

  Knowing about the “xml” attribute is helpful for troubleshooting because it shows the text/string representation of the NETCONF response from the device. It also allows you to compare the response to what you see when using the “| xmlout” option while on the NX-OS CLI

  The same response object as an attribute called “data_ele” which is the equivalent of an XML object in Python

  The final parts of the script introduce methods to search XML objects using the find method of XML objects in order to look for the element that has the value you are looking for

  In this case, it is <mod:hostname>nxosv</mod:hostname>

  Filters can be XML strings or XML objects. One may be preferred over the other based on the network application being built:
          device = manager.connect(host=host, port=port, username=user, password=pwd,
                                  hostkey_verify=False, device_params={'name': 'nexus'},
                                  allow_agent=False, look_for_keys=False)
            get_filter = """
                          <show>
                            <hostname>
                            </hostname>
                          </show>
                          """
            nc_get_reply = device.get(('subtree', get_filter))
            print nc_get_reply.xml
            ns_map = {'mod': 'http://www.cisco.com/nxos:1.0:vdc_mgr'}
            xml_rsp = nc_get_reply.data_ele.find(
                 './/mod:hostname', ns_map)
            value = xml_rsp.text
   OR:
            E = ElementMaker()
            nc_filter = E.show(
                E.hostname()
            )
            print etree.tostring(nc_filter)  # view XML obj as string

            nc_get_reply = device.get(('subtree', nc_filter))


      Required imports:
         from lxml import etree
         from lxml.builder import ElementMaker

    script used above:
            device = manager.connect(host=host, port=port, username=user, password=pwd,
                                  hostkey_verify=False, device_params={'name': 'nexus'},
                                  allow_agent=False, look_for_keys=False)
            get_filter = """
                          <show>
                            <hostname>
                            </hostname>
                          </show>
                          """
            nc_get_reply = device.get(('subtree', get_filter))
            print nc_get_reply.xml
            ns_map = {'mod': 'http://www.cisco.com/nxos:1.0:vdc_mgr'}
            xml_rsp = nc_get_reply.data_ele.find(
                 './/mod:hostname', ns_map)
            value = xml_rsp.text

            print value

            device.close_session()

      The script below also depicts another way to extract and find particular elements within the XML object that is returned from the device. In previous examples, you needed to use XML namespace maps when looking for particular elements. This example shows how it is possible to remove all namespaces simplifying the process of worrying about namespace maps when using the find method of XML objects.

        def remove_namespaces(xml):
                for elem in xml.getiterator():
                    split_tag = elem.tag.split('}')
                    if len(split_tag) > 1:
                        elem.tag = split_tag[1]
                return xml

         with manager.connect(host=host, port=port, username=user, password=pwd,
                              hostkey_verify=False, device_params={'name': 'nexus'},
                              allow_agent=False, look_for_keys=False) as device:

                get_filter = """
                              <show>
                                <version>
                                </version>
                              </show>
                              """
               nc_get_reply = device.get(('subtree', get_filter))
               nc_get_reply_no_ns = remove_namespaces(nc_get_reply.data_ele)
               xml_rsp = nc_get_reply_no_ns.find('.//kickstart_ver_str')
               value = xml_rsp.text
               print value

Note: There are multiple ways to establish a connection to the device. The above script in this figure introduces the use of a context manager (with statement) to establish the connection to the device. The value here is that you don’t have to worry about closing the connection to the device

Note: NETCONF Nexus-only exec-command sends raw CLI commands vs. XML strings.Leverages exec_command method as compared to get, edit_config, etc:
        with manager.connect(host=host, port=port, username=user, password=pwd,hostkey_verify=False, device_params={'name': 'nexus'},allow_agent=False, look_for_keys=False) as device:

            commands = ['config t', 'interface Ethernet2/6', 'description Configured by Python ncclient']
            nc_config_reply = device.exec_command(commands)

NX-API rest:
    NX-API REST is supported on Nexus 9000 and 3000 series switches starting with 7.0(3)I2(2). NX-API REST is the next-generation API for the Nexus platform in that it supports sending and receiving objects in the API payload. If you recall, NX-API CLI supports sending commands to the device while receiving structured data back (JSON, XML). With NX-API REST, it is completely based on structured data meaning that JSON/XML payloads are sent to the device in the http request and received from the device in the response

    The implementation of NX-API REST is similar to the model used by Cisco’s ACI. All information about the switch, including configuration and state data, is stored in a hierarchical tree that is called the Management Information Tree, and every object in the tree can be directly access via the REST API

    Every object in the Management Information Tree is referred to as a Managed Object.Each Managed Object is also of a certain type of class. For example, Ethernet interfaces are of type l1PhysIf and SVI interfaces are of type sviIf, but all interfaces are of type intf. These types are called classes

    It is important to understand the relationship, between DNs and classes because you can make an API to the Nexus switch using NX-API REST using a DN-based query or Class-based query. Example: query a single interface (DN) or query all interfaces of a given type (Class)

    The NX-API-REST API operates in forgiving mode, which means that missing attributes are substituted with default values (if applicable) that are maintained in the internal data management engine (aka DME). The DME validates and rejects incorrect attributes. The API is also atomic. If multiple MOs are being configured, and any of the MOs cannot be configured, the API stops its operation. It returns the configuration to its prior state, stops the API operation that listens for API requests, and returns an error code

    URLs and URIs map directly to distinguished names identifying objects on the tree, and any data on the MIT can be described as a self-contained structured text tree document encoded in XML or JavaScript Object Notation (JSON)

NX-API REST SUPPORTED HTTP VERBS:
    Each API implementation that supports REST supports a specific amount of HTTP verbs and methods. The NX-API REST API supports three methods: POST, GET, and DELETE

        GET: Used to retrieve and read information from the Management Information Tree

        DELETE: Used to delete and remove an object from the Management Information Tree

        POST: Used to create or update an object within the Management Information Tree. In the NX-API REST API, POSTs to the API are idempotent meaning that the change is made just once no matter how many times the API is called

NX-API REST API authorization, content-type, and accept-headers:
    There is a dedicated API to handle authorization when using the API. The device returns a token that is then sent in subsequent API calls that perform CRUD operations

    Regarding Content-Type and Accept, they are ignored by the Nexus switches. It is the case because the payload format must be specified as a file extension. All API calls using NX-API REST will have either “.json” or “.xml” appended to them letting the switch know what the content-type is and how to response, for example, with which encoding format

    e.g:
        http://n9k/api/mo/sys/intf/phys-[eth2/5].json
        http://n9k/api/mo/sys/bgp/inst.json

Constructing nx-api rest calls:
    Objects can be accessed at their well-defined address, their REST URLs, using standard HTTP commands for retrieval and manipulation of Cisco NX-API-REST object data

    The URL format that is used can be represented as follows: /api/[mo|class]/[dn|class][:method].[xml|json]?{options}

       The various building blocks of the preceding URL are as follows:
            System: System identifier; an IP address or DNS-resolvable host name
            mo | class: Indication of whether it is a managed object or tree or class-level query
            class: Managed-object class (as specified in the information model) of the objects queried; the class name is represented as
            dn: Distinguished name (unique hierarchical name of the object in the MIT tree) of the object queried
            method: Optional indication of the method being invoked on the object; applies only to HTTP POST requests
            xml | json: Encoding format
            options: Query options, filters, and arguments

NX-API rest call workflow:
    The typical sequence of configuration is:
        1- Authenticate: Call https://<IP of Nexus switch>/api/mo/aaaLogin.xml with a payload that in XML is. This call returns a cookie value that the browser uses for the next calls
        2- Send HTTP POST to apply the configuration: The URL of the POST message varies depending on the object, the following is an example: https://<IP of Nexus switch>//api/mo/sys/bgp/inst.json, where api indicates that this call is to the API, mo indicates that this call is to modify a managed object, bgp/inst refers to the BGP instance, and .json indicates that the payload is in JSON format. If the end of URL is .xml, that would mean that the payload is in XML format
        3- Verify the HTTP status code: One should want a response of 200 OK. With the capability to address and access an individual object or a class of objects with the REST URL, one can achieve complete programmatic access to the entire object tree and to the entire system

Note: With the capability to address and access an individual object or a class of objects with the REST URL, one can achieve complete programmatic access to the entire object tree and to the entire system

Examples nx-rest api call:
    authentication call - uses POST:
        URL: https://n9k2/api/aaaLogin.json

        Body:

        {
          "aaaUser":{
            "attributes":{
              "name": "cisco",
              "pwd": "cisco"
            }
          }
        }

        URL: https://n9k2/api/aaaLogin.xml
        Body:
        <aaaUser name="admin" pwd="C1sco12345"/>

    The URL to log in to the device is: https://device/api/aaaLogin.json. It must be an HTTP POST. As you can see, the file extension still needs to be provided to specify the type of payload being used. Based on the data encoding type that is chosen, you use either one of these two bodies to log in and authenticate to the device

    Here is an example of a Managed Object, or DN-based query. You know that based on the URI being used: /api/mo/sys/intf/phys-[eth2/5].json. You can also see that it is an HTTP GET, so you are only retrieving information with this API call

    Remember that /api/mo signifies it is a DN-based query, thus, a specific object is being queried and in this example, that object is physical interface Ethernet2/5. You can also see in the response two keys that are used quote often. The first is “totalCount” and this count is “1” and of course, it makes sense as there is only ONE Ethernet2/5 interface. All data in NX-API responses is returned in the “imdata” key. “imdata” is a list of dictionaries (JSON objects) and in this case, it is a list of one

    In this example, you can see that Postman is being used to make an HTTP POST request. This request is performing an admin down (shutdown) of Interface Ethernet2/5

    You can see /api/mo/sys/intf.json is the URI being used and as such. It means it is a DN-based query. But in this example, you can see that the parent object “intf” is specified in the URL and the individual object being modified is in the JSON payload

    You could have also used the full URI to specify Eth2/5 as well like: /api/mo/sys/intf/phys-[eth2/5].json and kept the same JSON body

    In this example, Postman is being used to make an HTTP GET request. This request is in contrast to previous examples as it is a class-based query. The URI being used here is: /api/class/l1PhysIf.json. Notice how it starts with /api/class instead of /api/mo

    All Ethernet interfaces are of type l1PhysIf which means you can query the class to obtain information for all interfaces (objects) within the class

    You should now have an understanding of class-based versus DN-based queries and API calls

Cisco nxtoolkit:
    Cisco has published a Python library that is called Nxtoolkit that is a set of Python modules that simplify getting started to use Python to program against the NX-API REST API. The library can be used to perform common operations such as collect information from Nexus devices but also to make configuration changes. Using Nxtoolkt eliminates the need to worry about the underlying URLs being used as they are abstracted away from the developer and built-into the library itself

    While Nxtoolkit is a Python library that simplifies working with the NX-API REST API on Nexus switches, it also comes with a collection of pre-built scripts that perform common operational tasks

    These pre-built scripts can be used immediately to eliminate the need to write any code – all you need to do is enter in specific device information such as credentials and IP address information and execute the script

    The Nxtoolkit is open source and available on GitHub at https://github.com/datacenter/nxtoolkit

Visore:
    Visore is a tool for NX-API REST that is built-into each switch. It is a managed object browser. It allows you to browse and navigate the Management Information Tree in real time and inspect the state of each and all objects. Visore is a great tool to understand and learn about the relationship between all objects of the system

    You can access Visore by navigating to http(s)://<nexus>/visore.html and authenticating using standard device credentials

    visore helps constructing the URL/URI

    Remember that there are two types of queries you can make when using the NX-API REST API. You can make a class-based query and a DN-based query

    This figure shows a class-based query being made for the class rmonEtherStats. Because it is a class, it is going to return interface stats for all associated interfaces. Notice how 63 objects are returned. Only the first one is shown in the figure, but you can see the first one displayed also includes an attribute for its DN

    You can also see that Visore is helpful in the sense that it has two links in the center that is left of the figure that say “Display URI of last query” and “Display last response.” By clicking “Display URI of last query,” you get to see the URI, which for this API call was:
        /api/node/class/rmonEtherStats.xml?query-target-filter=and(eq(rmonEtherStats.collisions,"0"))

    Once you have the URI, you are able to make native REST calls using Postman or equivalent. As you can see, the API also supports filters and using Visore simplifies learning how to use them by seeing the URIs generated automatically. This API call queried the device for all objects of class type rmonEtherStats but then added a filter to only return those that interface that had 0 collisions

    The previous figure was used to show how to make a class-based query for a specific interface. This example builds on it by using the DN provided in the API response from the class-based. This query, because it is based on DN, is specifically querying a single given object.

    If wanted to get the results in JSON, you could use the URI generated and add “.json” to it like so:
        /api/node/mo/sys/intf/phys-[eth1/3]/dbgEtherStats.json

    Comparing and contrasting class-based and DN-based queries one more time, you can see you can query all switched virtual interfaces on the system with the class-based query:
       /api/node/class/sviIf.xml

    Notice how there were 10 objects that were returned with this API call. It means that there was 10 SVIs on the switch when this API was executed on the switch

    You can also query a single SVI such as ‘interface vlan200’ with the following DN-based query:
        /api/node/mo/sys/intf/svi-[vlan200].xml

Note: /node is optional making API calls back into the system

Python on nexus switches:
    Nexus switches have a Python execution engine exposed that allow you to access the interpreter or run scripts directly on the switch.
        nxosv# python
        Copyright (c) 2001-2012 Python Software Foundation; All Rights Reserved
        nxosv# >>>

    The Nexus series switches have various APIs to enhance off box scripting capabilities, but there is also the ability to run Python scripts directly on each switch as well. There is a native Python execution engine that allows you to use the dynamic Python interpreter, was covered in the first module, directly from the switch command line. Also, you can also run standalone scripts from the command line.

    To enter the interactive Python interpreter, simply type in the word python and hit enter

Built-in python module:
    The Python environment on each Nexus switch comes with a pre-installed Python module called cisco. You can use standard helper functions on this module to see a list of it’s available methods and attributes and how to use them

    The help function can be used on the module itself as shown in the graphic, but the dir function can be used to see a summarized view of the available methods and attributes
    nxosv# >>> import cisco
    nxosv# >>> help(cisco)
    ## omitted for brevity ##
    FUNCTIONS
        cli(...)
            execute a cli command

        clid(...)
            execute a cli command, return name/value pairs

        clip(...)
            execute a cli command, dont return it, just display it

        set_vrf(...)
            specify the vrf name for socket operations
    nxosv# >>> dir(cisco)

    You can also use the help menu as you would normally to get help on a specific method:
        nxosv# >>> help(cisco.set_vrf)
    Help on built-in function set_vrf in module cisco:
        set_vrf(...)
           specify the vrf name for socket operations

    There are three core APIs, or methods, that are available to use within the cisco Python module. They are cli(), clip(), clid():
       They can be imported using a wildcard import:
           from cisco import *
       Or individually (and in good Python practice):
           from cisco import cli
           from cisco import clip
           from cisco import clid

    While they all execute commands natively on the local Nexus switch, the difference is in what each command returns and/or prints. The cli() method returns raw output just as if you were to connect to the device via SSH and execute commands while clip() does not return anything, but rather prints the output, which is just good for visualization

    On the other hand, clid() issues commands but returns a dictionary of key-value pairs instead of raw text as with cli(). It is the preferred method assuming the command that you want to execute has support for structured data. You can usually test for this while on the CLI using the command “show command | json”

    e.g:
            nxosv# >>> from cisco import cli
            nxosv# >>>
            nxosv# >>> cli('config t ; interface Eth2/8 ; shutdown ')
            ''
            nxosv(config-if)# >>>
            nxosv(config-if)# >>> cli('no shutdown ')
            ''
            nxosv(config-if)# >>>
            nxosv(config-if)# >>> print cli('where')
              conf; interface Ethernet2/8      ntc@nxosv%default

    You can also make configuration changes using the CLI methods. You can send a semi-colon de-limited string of commands in a single API call to the switch. It is quite common to build a list of commands and then use the join() method of string, to build the required string to send to the device with the cli() method as follows:
            nxosv# >>> commands = ['config t', 'interface Eth2/8', 'shutdown']
            nxosv# >>>
            nxosv# >>> cmd_string = ' ; '.join(commands)
            nxosv# >>>
            nxosv# >>> print cmd_string
            config t ; interface Eth2/8 ; shutdown
            nxosv# >>>
            nxosv# >>> cli(cmd_string)

Note: Pay special attention to various hardware platforms and if the commands are persistent through API calls

Executing script on nx switches:
    manually:
       nxosv# source check_transit_interfaces.py

    using scheduler feature:
        feature scheduler
        scheduler job name enforcer
          source enforce_config.py
        scheduler schedule name enforcer
          job name enforcer
          time start now repeat 00:00:10

    using EEM:
        event manager applet trigger_this
        event cli match "show version"
        action 1 cli command "source script.py"
        action 2 syslog priority critical msg “CLOCK COMMAND EXECUTED:
        action 3 event-default

    As you have seen, Nexus has an onboard Python interpreter. Also, you can run pre-built Python scripts directly on the box. Based on the size of the environment, there may be a reason to perform large computations on the box vs. running them off box using API calls to 100s or 1000s of switches in a given environment

    There is a directory that is called scripts within bootflash: on each Nexus switch. It is where scripts are meant to be saved. Once they are saved there, you can execute them directly on the switch using the source command

    You can gain even more flexibility by leveraging existing features such as scheduler and EEM as well. These features can be used to repeatedly execute scripts on a given schedule- possibly to examine interface counters or CRC errors, or you can even use EEM to dynamically execute a script when a given CLI command is executed as shown in the figure

Note: to view a script on nx cli:
    show file bootflash:scripts/ip_port_mapping.py

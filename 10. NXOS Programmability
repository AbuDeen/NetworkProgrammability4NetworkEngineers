NXOS supports two versions of NX-API including NX-API CLI and NX-API REST, NETCONF, on-box Linux and Python scripting capabilities, and several traditional means already familiar to network administrators including the Scheduler feature, Embedded Event Manager, Power on Provisioning

Nexus programmability overview:
     Day-0 Provisioning:
         Zero-Touch device provisioning is commonly associated with compute devices, but network devices have had this capability for years. Power on Auto Provisioning was designed to provide advanced Day-0 provisioning capabilities using an extensible framework. POAP includes the ability to execute Python scripts as part of its workflow. Today, POAP can download and install additional management agents and apply specific configurations that are based on information such as location in a network topology.

         A similar approach is achieved by using Pre-boot Execution Environment. PXE has extended its presence into the network as infrastructure devices are increasingly managed more like servers. NX-OS uses iPXE which utilizes an open source network firmware that is based on gPXE/Etherboot

     Base Features:
         In addition to providing traditional SNMP support, the Nexus platform also provides Python scripting capability on the devices in order to provide programmatic access to the switch CLI to perform various tasks including Power-On Auto Provisioning and Embedded Event Manager actions. The Python interpreter is included in the Cisco NX-OS software

     APIs:
        NX-OS provides a built-in webserver to respond to HTTP calls to the switch in order to improve accessibility, extend capability, and improve manageability of NX-OS. APIs include NETCONF, NX-API CLI, NX-API REST, and XMPP

    Linux on the Switch:
        Nexus switches have always been built upon a Linux foundation making available a native Linux Bash shell, but today NX-OS also provides a Linux guest shell which is a separate Linux environment running on the switch inside a container. Currently utilizing a CentOS distribution, a key benefit for the guest shell is the ability to securely run third-party applications that monitor and control the switch

    Configuration Management:
        NX-OS incorporates a set of tools, features, and capabilities that enable automation. Modern configuration management tools like Puppet, Chef, and Ansible drive programmability

NX-API cli - part1:
    On Cisco Nexus devices, command-line interfaces are run only on the device and used far too often to manage data center networks

    NX-API improves the accessibility of these CLIs by making them available outside of the switch by using HTTP/HTTPS. You can use the NX-API as an extension to the existing Cisco Nexus CLI. The NX-API CLI API is a great for network engineers getting started with the API as it still makes use of commands. It sends commands to the device, wrapped in http/https, but receives structured data back

    You have the ability to send show commands, configuration commands, and Linux commands directly to the switches using NX-API CLI

    The NX-API backend uses the Nginx HTTP server running on nexus switch. The Nginx process, and all its children processes, are under Linux cgroup protection where the CPU and memory usage is capped. If the Nginx resource usage exceeds the cgroup limitations, the Nginx process is restarted and restored

    The NX-API backend uses a lightweight onbox webserver to listen for HTTP requests which are converted to CLI and used to retrieve data or push configurations. The request/response format is encoded with JSON-RPC, JSON, or XML

    NX-API supports XML, JSON, and JSON-RPC, and commands are sent to a single http request within a CLI wrapper. The following examples show the same request and response for “show hostname” for all 3 data encoding formats:
            [
              {
                "jsonrpc": "2.0",
                "method": "cli",
                "params": {
                  "cmd": "show hostname",
                  "version": 1
                },
                "id": 1
              }
            ]

            Matching response

            {
              "jsonrpc": "2.0",
              "result": {
                "body": {
                  "hostname": “n9k2.cisco.com"
                }
              },
              "id": 1
            }

        NX-API supports HTTPS, therefore all communication to the Nexus device can be encrypted. By default, NX-API is integrated into the authentication system on the device. You access the device through the NX-API using user accounts containing a username and password which are contained in the HTTP header

        NX-API is disabled by default and can be enabled by using the feature manager CLI command. NX-API provides a session-based cookie, nxapi_auth, when users first successfully authenticate. The session cookie expires in 600 seconds which is a fixed value that cannot be modified

        With the session cookie, the username and password are included in all subsequent NX-API requests that are sent to the device. If the session cookie is not included with subsequent requests, another session cookie is required and is provided by the authentication process

Enabling nx-api cli:
    The nxapi feature must be enabled via the CLI
    Enable the feature via the command line
    Identify the alternate port being used (if any)
    Identify an HTTPS certificate file to use
    Enable the nxapi sandbox
nxosv# conf t
nxosv(config)# feature nxapi
nxosv(config)# nxapi https port 8443
nxosv(config)# nxapi sandbox

Note: In particular versions of NX-OS, you can also choose which VRF NX-API should be enabled for:
    nxos(config)# nxapi ?
     certificate  Https certificate configuration
     http         Http configuration
     https        Https configuration
     use-vrf      Vrf to be used for nxapi communication

NX-API sandbox:
    The NX-API sandbox is available on the switch itself (accessible via http://switchname) and accessed via a web browser. There are helpful buttons available with commonly used built-in scripts. It is a great way to become familiar with the API because you get to visualize the JSON/XML objects coming back without having to write actual code

    On the right are buttons that are used to select JSON-RPC, JSON, or XML encodings. Commands are entered in the Command Box and executed with the Post button. The Request being sent to the device is displayed in the Request box in the lower left, and the Response output from the device is displayed in the lower right

    When using JSON-RPC, you are always sending a list of JSON objects (dictionaries) even if it’s a list of one (single command). Here is an example of sending show version with the associated Request and Response.The Response is similar in that it’s always a list of dictionaries for JSON-RPC

Note: When using JSON encoding, you only receive a list in the response when you send more than one command as compared to JSON-RPC which always does. JSON sends a dictionary when sending one command but sends a list of dictionaries when sending more than one command

    The NX-API sandbox can convert CLI into Python automatically to help get you started. In the Request box, click the Python button. It uses a built-in Python requests module to convert the commands to a Python script that can be copied into a .py file

Note: keep in mind that api wrapper always use POST for sending cli commands in rest api calls

Note: cli-conf doesn't support structured data, so JSON/XML response will look just like you see it on the cli

NX-API cli - part 2:
    By using the NX-API Sandbox, you can auto-generate Python code to give you a jump a start on writing scripts. There is only a subtle difference with the script in the previous figure that is compared to this one, and it is around using a specific and preferred Python object to simplify authentication. You can see that everything else is nearly identical that is produced by the NX-API sandbox. Of course, it excludes any parsing that you would want to perform

    Take note that even though you are getting information back from the device, it is still an HTTP POST and it is shown using the post method and clicking the POST button within the NX-API sandbox. All requests using NX-API CLI use HTTP POSTs—it is one reason why NX-API CLI is REST-like

  #!/usr/bin/env python

  import requests
  import json
  from requests.auth import HTTPBasicAuth

  if __name__ == "__main__":

      auth = HTTPBasicAuth('cisco', 'cisco')
      headers = {
          'Content-Type': 'application/json'
      }
      payload = {
        "ins_api": {
            "version": "1.0",
            "type": "cli_show",
            "chunk": "0",
            "sid": "1",
            "input": "show version",
            "output_format": "json"
        }
    }
    url = 'http://nxosv/ins'

    response = requests.post(url, data=json.dumps(payload),
                             headers=headers, auth=auth)

  print 'Status Code: ' + str(response.status_code)
  rx_object = json.loads(response.text)
  print json.dumps(rx_object, indent=4)

Note: the url used: http://nxosv/ins

NETCONF:
    NETCONF on the Nexus platform is based off XML Schema Definitions data models and maps to CLI commands. Only supported on nexus 7k&5k, includes rollback on error, stop on error, continue on error, default operations, and candidate config (Cisco-only)

    Nexus supports the interface uses the XML-based Network Configuration Protocol which allows you to manage devices and communicate over the interface with an XML management tool or program. A sample tool that you will use throughout the course is the Python-based NETCONF client called ncclient as well as the on box NETCONF server that allows you to test XML documents

    The Cisco NX-OS implementation of NETCONF requires you to use an SSH session for communication with the device. NETCONF on the Nexus platform is currently implemented leveraging XML Schemas. From within an RPC message, you select one of the NETCONF operations that matches the type of command that you want the device to execute

    NETCONF requirements:
    In order to get started with NETCONF on the Nexus series switches, you must first prepare the client and the server. The client must support NETCONF over SSH as Nexus supports NETCONF as an SSH subsystem. On a Linux system, the default SSH configuration works just fine

    The server, for example, the Nexus switch, must have SSH enabled in order to use the NETCONF XML Management Interface

    No other licensing is required on the Nexus switch in order to use NETCONF

    NETCONF uses default SSH port (22)

    Accessing netconf on a nexus switch:
        The easiest way to directly access the NETCONF subsystem in order to test it is to access the xmlagent service on the Nexus switch. There are two ways to do it:

            You can SSH directly to the xmlagent service by using “-s” flag which tells the server to connect you to the xmlagent subsystem. Note: netconf works, too, as shown in the figure:     ssh cisco@nxosv -s {netconf | xmlagent}

            SSH directly to the switch. Enter the configuration mode and then enter the command xmlagent

        Once you use either of the two above methods, you can then start testing different XML documents that adhere to the XML schemas that Nexus supports

    netconf utilities and tools:
        There are five (5) unique commands and tools to be aware of when using NETCONF on Nexus series switches:
            xmlagent = The SSH service acting as the NETCONF server on the Nexus platform. When you enter the xmlagent command in configuration mode, you can test XML objects and filters directly on the device without being in code. It is similar to sandbox environments such as the NX-API Sandbox that shows you the objects that are required for the request and shows you object in the response. It is very helpful for testing.

            xmlin = an interactive utility to obtain XML Request documents of a particular show command or configuration object. When you enter xmlin configuration mode, you can enter any command as you would in exec or configuration mode. Once the command is entered, the switch displays the associated XML document to perform that action.

            “| xmlin” & “| xmlout” = The pipe options allow you to see the XML Documents for show commands. It includes seeing the XML Request documents (xmlin), but also it shows the XML Response documents (xmlout). Using the pipe options build on what can be in the xmlin tool because it does show you what the response is too.

            ncclient = ncclient is an open source Python NETCONF client. It aims to offer an intuitive API that sensibly maps the XML-encoded nature of NETCONF to Python objects and constructs

Connecting to netconf:
    When you connect to the device, authenticate, and access the Nexus NETCONF SSH subsystem, the device (NETCONF server) responds with its NETCONF capabilities. These capabilities can be based on open, vendor-neutral, or platform/vendor-specific capabilities.

    NETCONF over SSH is initiated by the exchange of a hello message between the client and the XML server. After the initial exchange, the client sends XML requests which the server responds to with XML responses. The client and server terminate requests and responses with the character sequence ]]>]]>.

    Because this character sequence is not valid in XML, the client and the server can interpret when the messages end which keeps communication that is synchronized

    After the NETCONF server (the Nexus switch) sends its capabilities, you (the XML client) must send a hello message with the capabilities that the client supports

    It is simply a copy and paste of a hello object. Everything in bold in this figure was the response by a user/client responding to the server’s hello message

Note: You must end all XML documents with ]]>]]> to support synchronization in NETCONF over SSH

    Once you send your capabilities, you can start sending XML documents to perform the equivalent of show and configuration commands

    e.g:
    Server's hello upon accessing xmlagent over ssh
        cisco@cisco:~$ ssh cisco@nxosv -s netconf
        User Access Verification
        Password:
        <?xml version="1.0" encoding="ISO-8859-1"?>
        <hello xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
          <capabilities>
            <capability>urn:ietf:params:xml:ns:netconf:base:1.0</capability>
            <capability>urn:ietf:params:netconf:base:1.0</capability>
            <capability>urn:ietf:params:netconf:capability:validate:1.0</capability>
            <capability>urn:ietf:params:netconf:capability:writable-running:1.0</capability>
            <capability>urn:ietf:params:netconf:capability:url:1.0?scheme=file</capability>
            <capability>urn:ietf:params:netconf:capability:rollback-on-error:1.0</capability>
            <capability>urn:ietf:params:netconf:capability:candidate:1.0</capability>
            <capability>urn:ietf:params:netconf:capability:confirmed-commit:1.0</capability>
          </capabilities>
          <session-id>12509</session-id>
        </hello>
        ]]>]]>

    client's response to hello:
          cisco@cisco:~$ ssh cisco@nxosv -s netconf
          User Access Verification
          Password:
          <?xml version="1.0" encoding="ISO-8859-1"?>
          <hello xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
          <--omitted – reference previous slide -->
          </hello>
          ]]>]]><?xml version="1.0"?>
          <hello xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
          <capabilities>
          <capability>urn:ietf:params:xml:ns:netconf:base:1.0</capability>
          <capability>urn:ietf:params:netconf:capability:rollback-on-error:1.0</capability>

    sample request:
        <?xml version="1.0" encoding="ISO-8859-1"?>
        <nf:rpc xmlns:nf="urn:ietf:params:xml:ns:netconf:base:1.0" xmlns="http://www.cisco.com/nxos:7.3.1.D1.1.:vdc_mgr" message-id="1">
          <nf:get>
            <nf:filter type="subtree">
              <show>
                <hostname/>
              </show>
            </nf:filter>
          </nf:get>
        </nf:rpc>
        ]]>]]>

       You can make out what it is doing based on the XML tags being used such as <show> and <hostname>. Note that these tags are wrapped under the rpc, get, and filter-type tags as well. It is telling the server that the request is an XML RPC using the NETCONF get operation and the content includes a filter, which is just the show hostname tags

Generating XML documents using the xmlin interactive shell:
    The Nexus platform offers a tool that is called xmlin which is an interactive shell that helps build the appropriate XML Request objects that are needed to communicate with the Nexus server. Enter the xmlin tool by issuing the command xmlin

    When you see the “nxosv(xmlin)#” prompt, you can start entering commands just as you would in exec and configuration mode. Entering the command show hostname generates the exact XML document that was used in the previous figure when interacting with the xmlagent service and tool

    The xmlin interactive tool can also be used to generate XML request documents for configuration objects. You still need to enter configuration mode and enter configuration mode commands just as you would on the NX-OS CLI

        nxosv(xmlin)# config t
        Enter configuration commands, one per line.  End with CNTL/Z.
        nxosv(config)(xmlin)# vlan 20
        % Success
        % Success
        nxosv(config-vlan)(xmlin)# name web_vlan
        % Success
        % Success
        nxosv(config-vlan)(xmlin)# end
        <?xml version="1.0"?>
        <nf:rpc xmlns:nf="urn:ietf:params:xml:ns:netconf:base:1.0" xmlns="http://www.cisco.com/nxos:7.3.1.D1.1.:configure_" xmlns:m="http://www.cisco.com/nxos:7.3.1.D1.1.:_exec" xmlns:m1="http://www.cisco.com/nxos:7.3.1.D1.1.:configure__vlan" message-id="1">
          <nf:edit-config>
            <nf:target>
              <nf:running/>
            </nf:target>
            <nf:config>
              <m:configure>
                <m:terminal>
                  <vlan>
                    <__XML__PARAM__vlan-id-create-delete>
                      <__XML__value>20</__XML__value>
                      <m1:name>
                        <m1:__XML__PARAM__vlan-name>
                          <m1:__XML__value>web_vlan</m1:__XML__value>
                        </m1:__XML__PARAM__vlan-name>
                      </m1:name>
                    </__XML__PARAM__vlan-id-create-delete>
                  </vlan>
                </m:terminal>
              </m:configure>
            </nf:config>
          </nf:edit-config>
        </nf:rpc>
        ]]>]]>

    The Nexus platform supports advanced operations such as being able to roll back the previous configuration when an error is found. It highlights the value of transactions and applying complete objects to Nexus switches such that if there is an error in any command, nothing gets applied to the device. It is in stark contrast to sending CLI commands. For example, if there was an error in command 4, commands 1 through 3 would still be applied, and you would end up with a partial configuration.

    In order to use the error on rollback option, you add the following option in the contents of the edit config operation:
         <nf:error-option>rollback-on-error</nf:error-option>

Generating xml documents for show commands:
    nxosv# show hostname | xmlout
    nxosv# show hostname | xmlin

Using ncclient (python netconf client):
    The ncclient is the common NETCONF client for Python. It only takes a few Python statements to establish a connection to the device, send XML documents, and receive a response

    There are many defaults being used here, but the important parameters to update as you connect to devices are host, port, username, password, and device_params
        device = manager.connect(host=host, port=port, username=user, password=pwd,hostkey_verify=False, device_params={'name': 'nexus'},allow_agent=False, look_for_keys=False)

    You can also see that you need to still need to define a filter the same way that is generated from using the “| xmlin” tool or “xmlin” interactive tool. It is shown in the script as the get_filter variable
        get_filter = """
                <show>
                <hostname>
                </hostname>
                </show>
                """

  In the next statement, the actual XML document is sent to the device. If you wanted to retrieve the full configuration, you would not need a filter, but because you want the hostname, you also include the “subtree” keyword, when using the get operation.
            nc_get_reply = device.get(('subtree', get_filter))

  As you continue to go through the script, notice that there is an attribute that is called “xml” in the NETCONF reply. In this example, the NETCONF reply is saved as “nc_get_reply” which means this object has an attribute that is called xml. This attribute stores the XML string equivalent of the actual XML object. In this figure, the string was split into two individual text boxes to improve readability

  Knowing about the “xml” attribute is helpful for troubleshooting because it shows the text/string representation of the NETCONF response from the device. It also allows you to compare the response to what you see when using the “| xmlout” option while on the NX-OS CLI

  The same response object as an attribute called “data_ele” which is the equivalent of an XML object in Python

  The final parts of the script introduce methods to search XML objects using the find method of XML objects in order to look for the element that has the value you are looking for

  In this case, it is <mod:hostname>nxosv</mod:hostname>

  Filters can be XML strings or XML objects. One may be preferred over the other based on the network application being built:
          device = manager.connect(host=host, port=port, username=user, password=pwd,
                                  hostkey_verify=False, device_params={'name': 'nexus'},
                                  allow_agent=False, look_for_keys=False)
            get_filter = """
                          <show>
                            <hostname>
                            </hostname>
                          </show>
                          """
            nc_get_reply = device.get(('subtree', get_filter))
            print nc_get_reply.xml
            ns_map = {'mod': 'http://www.cisco.com/nxos:1.0:vdc_mgr'}
            xml_rsp = nc_get_reply.data_ele.find(
                 './/mod:hostname', ns_map)
            value = xml_rsp.text
   OR:
            E = ElementMaker()
            nc_filter = E.show(
                E.hostname()
            )
            print etree.tostring(nc_filter)  # view XML obj as string

            nc_get_reply = device.get(('subtree', nc_filter))


      Required imports:
         from lxml import etree
         from lxml.builder import ElementMaker

    script used above:
            device = manager.connect(host=host, port=port, username=user, password=pwd,
                                  hostkey_verify=False, device_params={'name': 'nexus'},
                                  allow_agent=False, look_for_keys=False)
            get_filter = """
                          <show>
                            <hostname>
                            </hostname>
                          </show>
                          """
            nc_get_reply = device.get(('subtree', get_filter))
            print nc_get_reply.xml
            ns_map = {'mod': 'http://www.cisco.com/nxos:1.0:vdc_mgr'}
            xml_rsp = nc_get_reply.data_ele.find(
                 './/mod:hostname', ns_map)
            value = xml_rsp.text

            print value

            device.close_session()

      The script below also depicts another way to extract and find particular elements within the XML object that is returned from the device. In previous examples, you needed to use XML namespace maps when looking for particular elements. This example shows how it is possible to remove all namespaces simplifying the process of worrying about namespace maps when using the find method of XML objects.

        def remove_namespaces(xml):
                for elem in xml.getiterator():
                    split_tag = elem.tag.split('}')
                    if len(split_tag) > 1:
                        elem.tag = split_tag[1]
                return xml

         with manager.connect(host=host, port=port, username=user, password=pwd,
                              hostkey_verify=False, device_params={'name': 'nexus'},
                              allow_agent=False, look_for_keys=False) as device:

                get_filter = """
                              <show>
                                <version>
                                </version>
                              </show>
                              """
               nc_get_reply = device.get(('subtree', get_filter))
               nc_get_reply_no_ns = remove_namespaces(nc_get_reply.data_ele)
               xml_rsp = nc_get_reply_no_ns.find('.//kickstart_ver_str')
               value = xml_rsp.text
               print value

Note: There are multiple ways to establish a connection to the device. The above script in this figure introduces the use of a context manager (with statement) to establish the connection to the device. The value here is that you don’t have to worry about closing the connection to the device

Note: NETCONF Nexus-only exec-command sends raw CLI commands vs. XML strings.Leverages exec_command method as compared to get, edit_config, etc:
        with manager.connect(host=host, port=port, username=user, password=pwd,hostkey_verify=False, device_params={'name': 'nexus'},allow_agent=False, look_for_keys=False) as device:

            commands = ['config t', 'interface Ethernet2/6', 'description Configured by Python ncclient']
            nc_config_reply = device.exec_command(commands)


  
